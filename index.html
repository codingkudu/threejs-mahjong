<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>發 · Green Dragon</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect x='2' y='1' width='28' height='30' rx='4' fill='%23f5f0dc' stroke='%23c8b878' stroke-width='1.5'/><rect x='5' y='4' width='22' height='24' rx='2' fill='none' stroke='%23d4c494' stroke-width='0.8'/><text x='16' y='19' text-anchor='middle' font-size='18' font-weight='bold' font-family='serif' fill='%232e7d32'>發</text></svg>">
<style>
  @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=IM+Fell+English+SC&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #0a0a0a;
    color: #e8d5a3;
    font-family: 'IM Fell English SC', serif;
    overflow: hidden;
    height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  /* Dark green felt background texture */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background:
      radial-gradient(ellipse at 20% 50%, rgba(10, 40, 20, 0.6) 0%, transparent 60%),
      radial-gradient(ellipse at 80% 50%, rgba(5, 30, 15, 0.6) 0%, transparent 60%),
      repeating-linear-gradient(
        45deg,
        transparent,
        transparent 2px,
        rgba(255,255,255,0.01) 2px,
        rgba(255,255,255,0.01) 4px
      );
    background-color: #0d1a10;
    z-index: -1;
  }

  h1 {
    font-size: clamp(0.7rem, 1.5vw, 1rem);
    letter-spacing: 0.4em;
    text-transform: uppercase;
    color: #7a9e7a;
    margin-bottom: 8px;
    opacity: 0;
    animation: fadeUp 1s 0.5s forwards;
  }

  .subtitle {
    font-size: clamp(0.55rem, 1vw, 0.75rem);
    letter-spacing: 0.3em;
    color: #3a5a3a;
    margin-bottom: 24px;
    opacity: 0;
    animation: fadeUp 1s 0.8s forwards;
  }

  #canvas-container {
    width: min(420px, 90vw);
    height: min(420px, 60vh);
    cursor: grab;
    opacity: 0;
    animation: fadeUp 1s 1s forwards;
  }

  #canvas-container:active { cursor: grabbing; }

  canvas { display: block; }

  .hint {
    margin-top: 20px;
    font-size: 0.65rem;
    letter-spacing: 0.25em;
    color: #2a4a2a;
    opacity: 0;
    animation: fadeUp 1s 1.5s forwards;
  }

  .meaning {
    position: absolute;
    bottom: 32px;
    text-align: center;
    opacity: 0;
    animation: fadeUp 1s 1.8s forwards;
  }

  .meaning .char {
    font-family: 'Noto Serif SC', serif;
    font-size: clamp(1.5rem, 4vw, 2.5rem);
    color: #4caf50;
    text-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
    display: block;
  }

  .meaning .translation {
    font-size: 0.7rem;
    letter-spacing: 0.3em;
    color: #4a6e4a;
    margin-top: 4px;
  }

  @keyframes fadeUp {
    from { opacity: 0; transform: translateY(12px); }
    to { opacity: 1; transform: translateY(0); }
  }
</style>
</head>
<body>

<h1>Green Dragon · Mahjong</h1>
<div class="subtitle">Wind of Prosperity</div>

<div id="canvas-container"></div>

<p class="hint">drag to rotate · scroll to zoom</p>

<div class="meaning">
  <span class="char">發</span>
  <div class="translation">Prosperity · Fortune · To Flourish</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const container = document.getElementById('canvas-container');
const W = container.offsetWidth;
const H = container.offsetHeight;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(W, H);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(40, W / H, 0.1, 100);
camera.position.set(0, 0, 5);

// Lights
const ambient = new THREE.AmbientLight(0xfff5e0, 0.4);
scene.add(ambient);

const keyLight = new THREE.DirectionalLight(0xfffbe0, 1.2);
keyLight.position.set(3, 5, 4);
keyLight.castShadow = true;
scene.add(keyLight);

const fillLight = new THREE.DirectionalLight(0xd0ffe0, 0.3);
fillLight.position.set(-4, 0, 2);
scene.add(fillLight);

const rimLight = new THREE.DirectionalLight(0x80c0ff, 0.2);
rimLight.position.set(0, -3, -2);
scene.add(rimLight);

// Tile group
const tileGroup = new THREE.Group();
scene.add(tileGroup);

// Tile dimensions
const tw = 1.4, th = 1.8, td = 0.5;
const radius = 0.12;

// Rounded slab geometry
function createRoundedSlab(width, height, depth, r, segs) {
  const w = width / 2 - r;
  const h = height / 2 - r;
  const shape = new THREE.Shape();
  shape.moveTo(-w, -height / 2);
  shape.lineTo( w, -height / 2);
  shape.quadraticCurveTo( width/2, -height/2,  width/2, -h);
  shape.lineTo( width/2,  h);
  shape.quadraticCurveTo( width/2,  height/2,  w,  height/2);
  shape.lineTo(-w,  height/2);
  shape.quadraticCurveTo(-width/2,  height/2, -width/2,  h);
  shape.lineTo(-width/2, -h);
  shape.quadraticCurveTo(-width/2, -height/2, -w, -height/2);
  const geo = new THREE.ExtrudeGeometry(shape, {
    depth, bevelEnabled: true,
    bevelThickness: r, bevelSize: r, bevelOffset: -r, bevelSegments: segs,
  });
  geo.center();
  return geo;
}

// Front 3/4 ivory, back 1/4 green
const frontDepth = td * 0.75;
const backDepth  = td * 0.25;

const tileMat     = new THREE.MeshStandardMaterial({ color: 0xf5f0dc, roughness: 0.3, metalness: 0.05 });
const greenBodyMat= new THREE.MeshStandardMaterial({ color: 0x4caf50, roughness: 0.25, metalness: 0.05, transparent: true, opacity: 0.95 });

const ivoryMesh = new THREE.Mesh(createRoundedSlab(tw, th, frontDepth, radius, 8), tileMat);
const greenMesh = new THREE.Mesh(createRoundedSlab(tw, th, backDepth,  radius, 8), greenBodyMat);

ivoryMesh.castShadow = true;
greenMesh.castShadow = true;

// Shift so they sit flush against each other
// Each slab is centered; shift so they join at z=0
ivoryMesh.position.z =  backDepth / 2;
greenMesh.position.z = -frontDepth / 2;

tileGroup.add(ivoryMesh);
tileGroup.add(greenMesh);

// Draw 發 character to canvas texture — etched / carved look
function makeCharTexture() {
  const size = 512;
  const c = document.createElement('canvas');
  c.width = size; c.height = size;
  const ctx = c.getContext('2d');

  // Tile face - ivory
  ctx.fillStyle = '#f8f3e2';
  ctx.fillRect(0, 0, size, size);

  // Subtle inner border
  ctx.strokeStyle = 'rgba(180,160,100,0.3)';
  ctx.lineWidth = 8;
  ctx.strokeRect(28, 28, size - 56, size - 56);

  // Corner dots (classic mahjong detail)
  ctx.fillStyle = 'rgba(180,160,100,0.25)';
  const dotR = 10, margin = 48;
  [[margin, margin], [size-margin, margin], [margin, size-margin], [size-margin, size-margin]].forEach(([x, y]) => {
    ctx.beginPath();
    ctx.arc(x, y, dotR, 0, Math.PI * 2);
    ctx.fill();
  });

  // The 發 character — etched effect
  const fontSize = size * 0.62;
  const charFont = `bold ${fontSize}px "Noto Serif SC", serif`;
  const cx = size / 2, cy = size / 2 + 10;
  ctx.font = charFont;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // 1) Carved shadow (dark edge at top-left of groove)
  ctx.save();
  ctx.shadowColor = 'rgba(0, 0, 0, 0)';
  ctx.shadowBlur = 0;
  ctx.fillStyle = 'rgba(40, 60, 30, 0.45)';
  ctx.shadowColor = 'rgba(20, 35, 10, 0.6)';
  ctx.shadowBlur = 4;
  ctx.shadowOffsetX = -1.5;
  ctx.shadowOffsetY = -1.5;
  ctx.fillText('發', cx, cy);
  ctx.restore();

  // 2) Highlight edge (light catches bottom-right rim of carving)
  ctx.save();
  ctx.fillStyle = 'rgba(255, 255, 240, 0.35)';
  ctx.shadowColor = 'rgba(255, 255, 230, 0.5)';
  ctx.shadowBlur = 3;
  ctx.shadowOffsetX = 1.5;
  ctx.shadowOffsetY = 1.5;
  ctx.fillText('發', cx, cy);
  ctx.restore();

  // 3) Base carved fill — deep matte green sitting in the groove
  ctx.save();
  ctx.fillStyle = '#2a6e30';
  ctx.shadowColor = 'rgba(0, 0, 0, 0)';
  ctx.shadowBlur = 0;
  ctx.fillText('發', cx, cy);
  ctx.restore();

  // 4) Subtle dark inner shadow for depth in the groove
  ctx.save();
  ctx.globalCompositeOperation = 'source-atop';
  // We need to clip to the character shape for an inset shadow effect
  ctx.restore();

  return new THREE.CanvasTexture(c);
}

// Generate a bump map from the character shape
function makeCharBumpMap() {
  const size = 512;
  const c = document.createElement('canvas');
  c.width = size; c.height = size;
  const ctx = c.getContext('2d');

  // White = flush surface
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, size, size);

  const fontSize = size * 0.62;
  ctx.font = `bold ${fontSize}px "Noto Serif SC", serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const cx = size / 2, cy = size / 2 + 10;

  // Dark = recessed — the carved groove
  ctx.fillStyle = '#999999';
  ctx.fillText('發', cx, cy);

  // Soften edges for a rounded carving profile
  // Draw a slightly smaller, darker center for depth
  ctx.fillStyle = '#777777';
  ctx.fillText('發', cx, cy);

  return new THREE.CanvasTexture(c);
}

// Wait for font to load
document.fonts.ready.then(() => {
  const charTex = makeCharTexture();
  const charBump = makeCharBumpMap();
  const faceMat = new THREE.MeshStandardMaterial({
    map: charTex,
    bumpMap: charBump,
    bumpScale: 0.045,
    roughness: 0.35,
    metalness: 0.02,
  });

  // Green back texture
  function makeBackTexture() {
    const size = 512;
    const c = document.createElement('canvas');
    c.width = size; c.height = size;
    const ctx = c.getContext('2d');

    // Deep green base
    ctx.fillStyle = '#4caf50';
    ctx.fillRect(0, 0, size, size);

    // Lighter green inner border
    ctx.strokeStyle = 'rgba(100, 200, 100, 0.35)';
    ctx.lineWidth = 10;
    ctx.strokeRect(24, 24, size - 48, size - 48);

    // Diagonal cross-hatch pattern
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.lineWidth = 2;
    for (let i = -size; i < size * 2; i += 28) {
      ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i + size, size); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i - size, size); ctx.stroke();
    }

    // Center diamond ornament
    ctx.strokeStyle = 'rgba(100, 200, 100, 0.4)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(size/2, size/2 - 80);
    ctx.lineTo(size/2 + 60, size/2);
    ctx.lineTo(size/2, size/2 + 80);
    ctx.lineTo(size/2 - 60, size/2);
    ctx.closePath();
    ctx.stroke();

    // Center dot
    ctx.fillStyle = 'rgba(100, 220, 100, 0.5)';
    ctx.beginPath();
    ctx.arc(size/2, size/2, 8, 0, Math.PI * 2);
    ctx.fill();

    return new THREE.CanvasTexture(c);
  }

  const backTex = makeBackTexture();
  const backMat = new THREE.MeshStandardMaterial({
    map: backTex,
    roughness: 0.25,
    metalness: 0.05,
    transparent: true,
    opacity: 0.95,
  });

  // Apply ivory to the rounded tile body
  ivoryMesh.material = tileMat;

  // Front face plane with 發 character
  const frontPlane = new THREE.Mesh(
    new THREE.PlaneGeometry(tw - radius*2.5, th - radius*2.5),
    faceMat
  );
  frontPlane.position.z = (frontDepth / 2) + radius + backDepth/2 + 0.001;
  tileGroup.add(frontPlane);

  // Back face plane — green with pattern
  const backPlane = new THREE.Mesh(
    new THREE.PlaneGeometry(tw - radius*2.5, th - radius*2.5),
    backMat
  );
  backPlane.position.z = -(backDepth / 2) - radius - frontDepth/2 - 0.001;
  backPlane.rotation.y = Math.PI;
  tileGroup.add(backPlane);
});


// Shadow plane
const shadowGeo = new THREE.PlaneGeometry(6, 6);
const shadowMat = new THREE.ShadowMaterial({ opacity: 0.3 });
const shadowPlane = new THREE.Mesh(shadowGeo, shadowMat);
shadowPlane.rotation.x = -Math.PI / 2;
shadowPlane.position.y = -1.5;
shadowPlane.receiveShadow = true;
scene.add(shadowPlane);

// Mouse interaction
let isDragging = false;
let prevMouse = { x: 0, y: 0 };
let rotVel = { x: 0, y: 0 };
let targetRot = { x: 0.3, y: -0.4 };
let currentRot = { x: 0.3, y: -0.4 };

const el = renderer.domElement;

el.addEventListener('mousedown', e => { isDragging = true; prevMouse = { x: e.clientX, y: e.clientY }; });
el.addEventListener('touchstart', e => { isDragging = true; prevMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY }; });

window.addEventListener('mouseup', () => { isDragging = false; });
window.addEventListener('touchend', () => { isDragging = false; });

window.addEventListener('mousemove', e => {
  if (!isDragging) return;
  const dx = e.clientX - prevMouse.x;
  const dy = e.clientY - prevMouse.y;
  rotVel.y = dx * 0.01;
  rotVel.x = dy * 0.01;
  targetRot.y += dx * 0.01;
  targetRot.x += dy * 0.01;
  targetRot.x = Math.max(-1.2, Math.min(1.2, targetRot.x));
  prevMouse = { x: e.clientX, y: e.clientY };
});

window.addEventListener('touchmove', e => {
  if (!isDragging) return;
  const dx = e.touches[0].clientX - prevMouse.x;
  const dy = e.touches[0].clientY - prevMouse.y;
  targetRot.y += dx * 0.01;
  targetRot.x += dy * 0.01;
  targetRot.x = Math.max(-1.2, Math.min(1.2, targetRot.x));
  prevMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
});

// Scroll to zoom
el.addEventListener('wheel', e => {
  camera.position.z = Math.max(2.5, Math.min(9, camera.position.z + e.deltaY * 0.005));
});

// Auto-rotate when idle
let idleTimer = 0;
let autoRotate = false;

// Animation
let t = 0;
function animate() {
  requestAnimationFrame(animate);
  t += 0.016;

  if (!isDragging) {
    // Slow drift rotation
    targetRot.y += 0.004;
  }

  // Smooth interpolation
  currentRot.x += (targetRot.x - currentRot.x) * 0.08;
  currentRot.y += (targetRot.y - currentRot.y) * 0.08;

  tileGroup.rotation.x = currentRot.x;
  tileGroup.rotation.y = currentRot.y;

  // Gentle float
  tileGroup.position.y = Math.sin(t * 0.7) * 0.05;

  renderer.render(scene, camera);
}

animate();

// Resize
window.addEventListener('resize', () => {
  const w = container.offsetWidth;
  const h = container.offsetHeight;
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
});
</script>
</body>
</html>
